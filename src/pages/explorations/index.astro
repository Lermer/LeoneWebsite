---
import { buildGraphData } from '../../utils/graphData';

const graphData = await buildGraphData();
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Explorations - Mind Map</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background-color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }

    #graph-container {
      width: 100vw;
      height: 100vh;
    }

    #controls {
      position: fixed;
      top: 20px;
      right: 20px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
      width: 320px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      font-size: 13px;
      z-index: 1000;
    }

    #controls h3 {
      margin: 0 0 15px 0;
      font-size: 14px;
      font-weight: 600;
    }

    .control-group {
      margin-bottom: 15px;
    }

    .control-group label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 12px;
      color: #666;
    }

    .control-group input[type="range"] {
      width: 100%;
      margin: 0;
    }

    .value-display {
      font-weight: 600;
      color: #333;
      font-family: 'Monaco', 'Menlo', monospace;
    }

    #copy-button {
      width: 100%;
      padding: 10px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      margin-top: 10px;
    }

    #copy-button:hover {
      background: #0052a3;
    }

    #copy-button:active {
      background: #004080;
    }

    #copy-button.copied {
      background: #28a745;
    }

    .toggle-button {
      position: fixed;
      top: 20px;
      right: 20px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 13px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      z-index: 999;
    }

    #controls.hidden {
      display: none;
    }
  </style>
  <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>
<body>
  <button class="toggle-button" id="toggle-controls">Physics Controls</button>

  <div id="controls">
    <h3>Physics Settings</h3>

    <div class="control-group">
      <label>
        <span>Gravitational Constant</span>
        <span class="value-display" id="gravitationalConstant-value">-26</span>
      </label>
      <input type="range" id="gravitationalConstant" min="-100" max="-1" step="1" value="-26">
    </div>

    <div class="control-group">
      <label>
        <span>Central Gravity</span>
        <span class="value-display" id="centralGravity-value">0.005</span>
      </label>
      <input type="range" id="centralGravity" min="0" max="0.1" step="0.001" value="0.005">
    </div>

    <div class="control-group">
      <label>
        <span>Spring Length</span>
        <span class="value-display" id="springLength-value">150</span>
      </label>
      <input type="range" id="springLength" min="50" max="300" step="10" value="150">
    </div>

    <div class="control-group">
      <label>
        <span>Spring Constant (elasticity)</span>
        <span class="value-display" id="springConstant-value">0.08</span>
      </label>
      <input type="range" id="springConstant" min="0.01" max="0.2" step="0.01" value="0.08">
    </div>

    <div class="control-group">
      <label>
        <span>Damping (velocity decay)</span>
        <span class="value-display" id="damping-value">0.6</span>
      </label>
      <input type="range" id="damping" min="0.1" max="0.99" step="0.01" value="0.6">
    </div>

    <div class="control-group">
      <label>
        <span>Avoid Overlap</span>
        <span class="value-display" id="avoidOverlap-value">0.3</span>
      </label>
      <input type="range" id="avoidOverlap" min="0" max="1" step="0.1" value="0.3">
    </div>

    <div class="control-group">
      <label>
        <span>Max Velocity</span>
        <span class="value-display" id="maxVelocity-value">30</span>
      </label>
      <input type="range" id="maxVelocity" min="1" max="50" step="1" value="30">
    </div>

    <div class="control-group">
      <label>
        <span>Timestep</span>
        <span class="value-display" id="timestep-value">0.4</span>
      </label>
      <input type="range" id="timestep" min="0.1" max="1" step="0.05" value="0.4">
    </div>

    <button id="copy-button">Copy Settings</button>
  </div>

  <div id="graph-container"></div>

  <script type="module" define:vars={{ graphData }} is:inline>
    console.log('Graph data:', graphData);

    // Transform data for vis.js
    const nodes = new vis.DataSet(
      graphData.nodes.map(node => ({
        id: node.id,
        label: node.label,
        color: node.exists ? '#000000' : '#999999',
        font: {
          color: '#333333',
          size: 12,
          face: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
        },
        shape: 'dot',
        size: 8
      }))
    );

    const edges = new vis.DataSet(
      graphData.links.map((link, index) => ({
        id: index,
        from: link.source,
        to: link.target,
        color: {
          color: '#999999',
          opacity: 0.6
        },
        width: 1.5,
        smooth: false
      }))
    );

    // Create network
    const container = document.getElementById('graph-container');
    const data = { nodes, edges };

    const options = {
      physics: {
        enabled: true,
        forceAtlas2Based: {
          gravitationalConstant: -50,
          centralGravity: 0.01,
          springLength: 150,
          springConstant: 0.08,
          damping: 0.4,
          avoidOverlap: 0.5
        },
        maxVelocity: 50,
        solver: 'forceAtlas2Based',
        timestep: 0.35,
        stabilization: {
          enabled: true,
          iterations: 1000,
          updateInterval: 25
        }
      },
      interaction: {
        dragNodes: true,
        dragView: true,
        zoomView: true,
        hover: true,
        navigationButtons: false,
        keyboard: false
      },
      nodes: {
        borderWidth: 0,
        borderWidthSelected: 0
      },
      edges: {
        selectionWidth: 0
      }
    };

    const network = new vis.Network(container, data, options);

    // Physics parameters object (will be used by sliders)
    const physicsParams = {
      gravitationalConstant: -26,
      centralGravity: 0.005,
      springLength: 150,
      springConstant: 0.08,
      damping: 0.6,
      avoidOverlap: 0.3,
      maxVelocity: 30,
      timestep: 0.4
    };

    function updatePhysics() {
      network.setOptions({
        physics: {
          enabled: true,
          forceAtlas2Based: {
            gravitationalConstant: physicsParams.gravitationalConstant,
            centralGravity: physicsParams.centralGravity,
            springLength: physicsParams.springLength,
            springConstant: physicsParams.springConstant,
            damping: physicsParams.damping,
            avoidOverlap: physicsParams.avoidOverlap
          },
          maxVelocity: physicsParams.maxVelocity,
          solver: 'forceAtlas2Based',
          timestep: physicsParams.timestep
        }
      });
    }

    // After stabilization, apply initial physics settings
    network.once('stabilizationIterationsDone', () => {
      updatePhysics();
    });

    // Track selected node
    let selectedNode = null;

    // Click handler
    network.on('click', function(params) {
      if (params.nodes.length > 0) {
        const nodeId = params.nodes[0];

        if (selectedNode === nodeId) {
          // Deselect
          selectedNode = null;

          // Reset all nodes
          graphData.nodes.forEach(n => {
            nodes.update({
              id: n.id,
              color: n.exists ? '#000000' : '#999999'
            });
          });

          // Reset all edges
          edges.forEach(e => {
            edges.update({
              id: e.id,
              color: {
                color: '#999999',
                opacity: 0.6
              }
            });
          });
        } else {
          // Select node
          selectedNode = nodeId;

          // Update nodes
          graphData.nodes.forEach(n => {
            nodes.update({
              id: n.id,
              color: n.id === nodeId ? '#4169E1' : (n.exists ? '#000000' : '#999999')
            });
          });

          // Update edges
          const connectedEdges = network.getConnectedEdges(nodeId);
          edges.forEach(e => {
            const isConnected = connectedEdges.includes(String(e.id));
            edges.update({
              id: e.id,
              color: {
                color: isConnected ? '#4169E1' : '#999999',
                opacity: isConnected ? 1 : 0.6
              }
            });
          });
        }
      } else {
        // Clicked on canvas - deselect all
        selectedNode = null;

        // Reset all nodes
        graphData.nodes.forEach(n => {
          nodes.update({
            id: n.id,
            color: n.exists ? '#000000' : '#999999'
          });
        });

        // Reset all edges
        edges.forEach(e => {
          edges.update({
            id: e.id,
            color: {
              color: '#999999',
              opacity: 0.6
            }
          });
        });
      }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      network.fit();
    });

    // Wire up sliders
    Object.keys(physicsParams).forEach(param => {
      const slider = document.getElementById(param);
      const valueDisplay = document.getElementById(param + '-value');

      slider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        physicsParams[param] = value;
        valueDisplay.textContent = value;
        updatePhysics();
      });
    });

    // Toggle controls visibility
    const toggleButton = document.getElementById('toggle-controls');
    const controlsPanel = document.getElementById('controls');
    let controlsVisible = true;

    toggleButton.addEventListener('click', () => {
      controlsVisible = !controlsVisible;
      if (controlsVisible) {
        controlsPanel.classList.remove('hidden');
        toggleButton.style.display = 'none';
      } else {
        controlsPanel.classList.add('hidden');
        toggleButton.style.display = 'block';
      }
    });

    // Initially hide toggle button since controls are visible
    toggleButton.style.display = 'none';

    // Add close button functionality (click outside to close)
    document.addEventListener('click', (e) => {
      if (!controlsPanel.contains(e.target) && !toggleButton.contains(e.target) && controlsVisible) {
        if (e.target.closest('#graph-container')) {
          controlsPanel.classList.add('hidden');
          toggleButton.style.display = 'block';
          controlsVisible = false;
        }
      }
    });

    // Copy settings to clipboard
    const copyButton = document.getElementById('copy-button');
    copyButton.addEventListener('click', async () => {
      const settings = `gravitationalConstant: ${physicsParams.gravitationalConstant}
centralGravity: ${physicsParams.centralGravity}
springLength: ${physicsParams.springLength}
springConstant: ${physicsParams.springConstant}
damping: ${physicsParams.damping}
avoidOverlap: ${physicsParams.avoidOverlap}
maxVelocity: ${physicsParams.maxVelocity}
timestep: ${physicsParams.timestep}`;

      try {
        await navigator.clipboard.writeText(settings);
        copyButton.textContent = 'Copied!';
        copyButton.classList.add('copied');
        setTimeout(() => {
          copyButton.textContent = 'Copy Settings';
          copyButton.classList.remove('copied');
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    });
  </script>
</body>
</html>
