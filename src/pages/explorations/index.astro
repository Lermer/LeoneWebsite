---
import { buildGraphData } from '../../utils/graphData';

const graphData = await buildGraphData();
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Explorations - Mind Map</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background-color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }

    #graph-container {
      width: 100vw;
      height: 100vh;
    }
  </style>
  <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>
<body>
  <div id="graph-container"></div>

  <script type="module" define:vars={{ graphData }} is:inline>
    console.log('Graph data:', graphData);

    // Transform data for vis.js
    const nodes = new vis.DataSet(
      graphData.nodes.map(node => ({
        id: node.id,
        label: node.label,
        color: node.exists ? '#000000' : '#999999',
        font: {
          color: '#333333',
          size: 12,
          face: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
        },
        shape: 'dot',
        size: 8
      }))
    );

    const edges = new vis.DataSet(
      graphData.links.map((link, index) => ({
        id: index,
        from: link.source,
        to: link.target,
        color: {
          color: '#999999',
          opacity: 0.6
        },
        width: 1.5,
        smooth: false
      }))
    );

    // Create network
    const container = document.getElementById('graph-container');
    const data = { nodes, edges };

    const options = {
      physics: {
        enabled: true,
        forceAtlas2Based: {
          gravitationalConstant: -50,
          centralGravity: 0.01,
          springLength: 150,
          springConstant: 0.08,
          damping: 0.4,
          avoidOverlap: 0.5
        },
        maxVelocity: 50,
        solver: 'forceAtlas2Based',
        timestep: 0.35,
        stabilization: {
          enabled: true,
          iterations: 1000,
          updateInterval: 25
        }
      },
      interaction: {
        dragNodes: true,
        dragView: true,
        zoomView: true,
        hover: true,
        navigationButtons: false,
        keyboard: false
      },
      nodes: {
        borderWidth: 0,
        borderWidthSelected: 0
      },
      edges: {
        selectionWidth: 0
      }
    };

    const network = new vis.Network(container, data, options);

    // Track selected node
    let selectedNode = null;

    // Click handler
    network.on('click', function(params) {
      if (params.nodes.length > 0) {
        const nodeId = params.nodes[0];

        if (selectedNode === nodeId) {
          // Deselect
          selectedNode = null;

          // Reset all nodes
          graphData.nodes.forEach(n => {
            nodes.update({
              id: n.id,
              color: n.exists ? '#000000' : '#999999'
            });
          });

          // Reset all edges
          edges.forEach(e => {
            edges.update({
              id: e.id,
              color: {
                color: '#999999',
                opacity: 0.6
              }
            });
          });
        } else {
          // Select node
          selectedNode = nodeId;

          // Update nodes
          graphData.nodes.forEach(n => {
            nodes.update({
              id: n.id,
              color: n.id === nodeId ? '#4169E1' : (n.exists ? '#000000' : '#999999')
            });
          });

          // Update edges
          const connectedEdges = network.getConnectedEdges(nodeId);
          edges.forEach(e => {
            const isConnected = connectedEdges.includes(String(e.id));
            edges.update({
              id: e.id,
              color: {
                color: isConnected ? '#4169E1' : '#999999',
                opacity: isConnected ? 1 : 0.6
              }
            });
          });
        }
      } else {
        // Clicked on canvas - deselect all
        selectedNode = null;

        // Reset all nodes
        graphData.nodes.forEach(n => {
          nodes.update({
            id: n.id,
            color: n.exists ? '#000000' : '#999999'
          });
        });

        // Reset all edges
        edges.forEach(e => {
          edges.update({
            id: e.id,
            color: {
              color: '#999999',
              opacity: 0.6
            }
          });
        });
      }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      network.fit();
    });

    // Subtle mouse interaction effects
    let mouseX = 0;
    let mouseY = 0;
    let isDragging = false;
    const nodeOriginalPositions = new Map();

    // Store original positions after stabilization
    network.once('stabilizationIterationsDone', () => {
      const positions = network.getPositions();
      Object.entries(positions).forEach(([nodeId, pos]) => {
        nodeOriginalPositions.set(nodeId, { x: pos.x, y: pos.y });
      });
    });

    // Track mouse position
    container.addEventListener('mousemove', (event) => {
      mouseX = event.clientX;
      mouseY = event.clientY;
    });

    // Track dragging state
    network.on('dragStart', () => {
      isDragging = true;
    });

    network.on('dragEnd', () => {
      isDragging = false;
      // Update original positions after drag
      setTimeout(() => {
        const positions = network.getPositions();
        Object.entries(positions).forEach(([nodeId, pos]) => {
          nodeOriginalPositions.set(nodeId, { x: pos.x, y: pos.y });
        });
      }, 100);
    });

    // Subtle parallax and repulsion effect
    let animationFrameId;
    const REPULSION_RADIUS = 120; // Distance at which repulsion starts
    const REPULSION_STRENGTH = 25; // Max pixels to push away
    const PARALLAX_STRENGTH = 0.015; // How much the view shifts (1.5%)

    function updateMouseEffects() {
      if (!isDragging && nodeOriginalPositions.size > 0) {
        // Get canvas position in DOM coordinates
        const canvasPos = network.getViewPosition();
        const scale = network.getScale();

        // Convert mouse position to canvas coordinates
        const DOMtoCanvas = network.DOMtoCanvas({ x: mouseX, y: mouseY });

        // Apply subtle parallax effect to the view
        const centerX = container.clientWidth / 2;
        const centerY = container.clientHeight / 2;
        const offsetX = (mouseX - centerX) * PARALLAX_STRENGTH;
        const offsetY = (mouseY - centerY) * PARALLAX_STRENGTH;

        // Smoothly move view (very subtle)
        const currentPos = network.getViewPosition();
        const targetX = canvasPos.x - offsetX;
        const targetY = canvasPos.y - offsetY;

        network.moveTo({
          position: {
            x: currentPos.x + (targetX - currentPos.x) * 0.05,
            y: currentPos.y + (targetY - currentPos.y) * 0.05
          },
          animation: false
        });

        // Apply gentle repulsion to nearby nodes
        const positions = network.getPositions();
        const updates = [];

        Object.entries(positions).forEach(([nodeId, pos]) => {
          const original = nodeOriginalPositions.get(nodeId);
          if (!original) return;

          // Calculate distance from mouse to node
          const dx = pos.x - DOMtoCanvas.x;
          const dy = pos.y - DOMtoCanvas.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < REPULSION_RADIUS && distance > 0) {
            // Calculate repulsion force (stronger when closer)
            const force = (1 - distance / REPULSION_RADIUS) * REPULSION_STRENGTH;
            const angle = Math.atan2(dy, dx);

            // Apply repulsion from mouse position
            const repelX = Math.cos(angle) * force;
            const repelY = Math.sin(angle) * force;

            updates.push({
              id: nodeId,
              x: original.x + repelX,
              y: original.y + repelY
            });
          } else {
            // Gently return to original position
            const returnSpeed = 0.1;
            updates.push({
              id: nodeId,
              x: pos.x + (original.x - pos.x) * returnSpeed,
              y: pos.y + (original.y - pos.y) * returnSpeed
            });
          }
        });

        if (updates.length > 0) {
          network.body.data.nodes.update(updates);
        }
      }

      animationFrameId = requestAnimationFrame(updateMouseEffects);
    }

    // Start the animation loop after stabilization
    network.once('stabilizationIterationsDone', () => {
      updateMouseEffects();
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    });
  </script>
</body>
</html>
